import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:livekit_client/livekit_client.dart';
import 'package:logger/logger.dart';
import 'services/livekit_token_generator.dart';

class LiveKitService extends ChangeNotifier {
  static final LiveKitService _instance = LiveKitService._internal();
  factory LiveKitService() => _instance;
  LiveKitService._internal();

  final Logger _logger = Logger();

  // Room and connection state
  Room? _room;
  bool _isConnected = false;
  bool _isConnecting = false;
  String _connectionStatus = 'Disconnected';
  String? _error;

  // Participants
  LocalParticipant? _localParticipant;
  List<RemoteParticipant> _remoteParticipants = [];
  int _participantCount = 0;

  // Audio state
  bool _isMicrophoneMuted = true;
  bool _isAudioEnabled = false;

  // Agent message capture
  List<String> _agentMessages = [];
  String _latestAgentText = '';
  String? _dailyBriefing;
  bool _dailyBriefingReceived = false;
  final StreamController<String> _agentMessageController = StreamController<String>.broadcast();
  
  // Live transcript capture
  String _currentLiveTranscript = '';
  String _currentUserTranscript = '';
  bool _isAgentSpeaking = false;
  bool _isUserSpeaking = false;
  final StreamController<Map<String, dynamic>> _liveTranscriptController = StreamController<Map<String, dynamic>>.broadcast();

  // Public getters
  bool get isConnected => _isConnected;
  bool get isConnecting => _isConnecting;
  String get connectionStatus => _connectionStatus;
  String? get error => _error;
  bool get isMicrophoneMuted => _isMicrophoneMuted;
  bool get isAudioEnabled => _isAudioEnabled;
  List<RemoteParticipant> get remoteParticipants => _remoteParticipants;
  LocalParticipant? get localParticipant => _localParticipant;
  int get participantCount => _participantCount;
  Room? get room => _room;
  
  // Agent message getters
  List<String> get agentMessages => List.unmodifiable(_agentMessages);
  String get latestAgentText => _latestAgentText;
  String? get dailyBriefing => _dailyBriefing;
  bool get dailyBriefingReceived => _dailyBriefingReceived;
  Stream<String> get agentMessageStream => _agentMessageController.stream;
  
  // Live transcript getters
  String get currentLiveTranscript => _currentLiveTranscript;
  String get currentUserTranscript => _currentUserTranscript;
  bool get isAgentSpeaking => _isAgentSpeaking;
  bool get isUserSpeaking => _isUserSpeaking;
  Stream<Map<String, dynamic>> get liveTranscriptStream => _liveTranscriptController.stream;

  Future<void> initialize() async {
    if (_isConnecting || _isConnected) return;
    
    _logger.i('ğŸš€ Initializing LiveKit service...');
    await connect();
  }

  // User configuration for dynamic user ID
  String? _currentUserId;
  int? _currentChatlogId;
  int? _currentAgentId;
  String? _currentUserEmail;
  String? _currentUserName;

  // Getters for user configuration
  String? get currentUserId => _currentUserId;
  int? get currentChatlogId => _currentChatlogId;
  int? get currentAgentId => _currentAgentId;
  String? get currentUserEmail => _currentUserEmail;
  String? get currentUserName => _currentUserName;

  // Method to set user configuration
  void setUserConfiguration({
    String? userId,
    int? chatlogId,
    int? agentId,
    String? userEmail,
    String? userName,
  }) {
    _currentUserId = userId;
    _currentChatlogId = chatlogId;
    _currentAgentId = agentId;
    _currentUserEmail = userEmail;
    _currentUserName = userName;
    
    _logger.i('ğŸ‘¤ User configuration set: userId=$userId, chatlogId=$chatlogId, agentId=$agentId');
    notifyListeners();
  }

  Future<void> connect() async {
    if (_isConnecting || _isConnected) return;

    try {
      _isConnecting = true;
      _connectionStatus = 'Connecting...';
      _error = null;
      notifyListeners();

      _logger.i('ğŸ”— Connecting to LiveKit...');

      _room = Room();
      _setupRoomListeners();

      // Generate token with user metadata
      _logger.i('ğŸ« Generating token with user metadata...');
      final token = LiveKitTokenGenerator.generateTokenWithMetadata(
        roomName: 'Tester-room1',
        identity: 'Mobile-hr-worker',
        metadata: {
          'user_id': _currentUserId ?? 'default-user',
          'chatlog_id': _currentChatlogId?.toString() ?? '7747',
          'agent_id': _currentAgentId?.toString() ?? '6',
          'user_email': _currentUserEmail ?? '',
          'user_name': _currentUserName ?? 'Mobile User',
        },
      );
      final url = LiveKitTokenGenerator.getServerUrl();

      _logger.i('ğŸŒ Connecting to URL: $url');
      _logger.i('ğŸ  Room: Tester-room1');
      _logger.i('ğŸ‘¤ Identity: Mobile-hr-worker');
      
      await _room!.connect(url, token);
      _logger.i('âœ… Connected to LiveKit room');

      _isConnected = true;
      _isConnecting = false;
      _connectionStatus = 'Connected';

      // Send user configuration to agent after successful connection
      await sendUserConfigurationToAgent();

      // Enable microphone for full-duplex audio
      await _enableAudioWithDelay();

      notifyListeners();
    } catch (error) {
      _logger.e('âŒ Connection failed: $error');
      _logger.e('ğŸ“‹ Error details: ${error.runtimeType}');
      _handleConnectionError('Connection failed: ${error.toString()}');
    }
  }

  void _setupRoomListeners() {
    if (_room == null) return;

    // Enhanced room state listener with debug
    _room!.addListener(() {
      print('ğŸ” ============== ROOM STATE CHANGED ==============');
      print('ğŸ” Remote Participants: ${_room!.remoteParticipants.length}');
      for (final participant in _room!.remoteParticipants.values) {
        print('ğŸ”   - ${participant.identity} (${participant.sid})');
        print('ğŸ”     Audio Tracks: ${participant.audioTrackPublications.length}');
        print('ğŸ”     Video Tracks: ${participant.videoTrackPublications.length}');
        print('ğŸ”     Data Tracks: ${participant.trackPublications.values.where((p) => p.kind == TrackType.DATA).length}');
      }
      print('ğŸ” ===============================================');
      
      _updateParticipants();
      notifyListeners();
    });

    // Add comprehensive event listeners for agent message capture
    final listener = _room!.createListener();
    
    // CATCH ALL EVENTS - Log everything for debugging
    print('ğŸ” =============== SETTING UP ALL EVENT LISTENERS ===============');
    print('ğŸ” Listening for ALL events from agents...');
    print('ğŸ” =============================================================');
    
    listener
      ..on<RoomConnectedEvent>((event) {
        print('ğŸ” =============== ROOM CONNECTED EVENT ===============');
        print('ğŸ” Room Name: ${event.room.name}');
        print('ğŸ” Room State: ${event.room.connectionState}');
        print('ğŸ” ===================================================');
        _logger.i('ğŸ‰ Room connected successfully');
      })
      ..on<RoomDisconnectedEvent>((event) {
        _logger.i('ğŸ‘‹ Room disconnected');
        _handleConnectionError('Room disconnected: ${event.reason}');
      })
      ..on<ParticipantConnectedEvent>((event) {
        final participant = event.participant;
        
        // DEBUG LOGGING FOR PARTICIPANT
        print('ğŸ” =============== PARTICIPANT CONNECTED DEBUG ===============');
        print('ğŸ” Participant Identity: ${participant.identity}');
        print('ğŸ” Participant Metadata: ${participant.metadata}');
        print('ğŸ” Participant Attributes: ${participant.attributes}');
        print('ğŸ” Participant Kind: ${participant.kind}');
        print('ğŸ” ========================================================');
        
        _logger.i('ğŸ‘¤ Participant joined: ${participant.identity}');
        
        // Check if this is an AI agent
        final isAgent = participant.identity.toLowerCase().contains('agent') || 
                       participant.identity.toLowerCase().contains('assistant') ||
                       participant.identity.toLowerCase().contains('voice') ||
                       participant.attributes['lk.agent'] == 'true';
        
        print('ğŸ” Agent Detection Result: $isAgent');
        
        if (isAgent) {
          print('ğŸ¤– âœ… AI AGENT DETECTED: ${participant.identity}');
          _logger.i('ğŸ¤– AI Agent detected: ${participant.identity}');
          // Note: Data messages will be received via DataReceivedEvent automatically
        } else {
          print('âŒ Not detected as agent: ${participant.identity}');
        }
      })
      ..on<ParticipantDisconnectedEvent>((event) {
        final participant = event.participant;
        _logger.i('ğŸ‘‹ Participant left: ${participant.identity}');
      })
      ..on<TrackPublishedEvent>((event) {
        final publication = event.publication;
        final participant = event.participant;
        
        // DEBUG LOGGING FOR TRACK PUBLISHED
        print('ğŸ” ================ TRACK PUBLISHED DEBUG ================');
        print('ğŸ” Track Kind: ${publication.kind}');
        print('ğŸ” Track Source: ${publication.source}');
        print('ğŸ” Track Name: ${publication.name}');
        print('ğŸ” Track Subscribed: ${publication.subscribed}');
        print('ğŸ” From Participant: ${participant.identity}');
        print('ğŸ” Participant Attributes: ${participant.attributes}');
        print('ğŸ” ======================================================');
        
        _logger.i('ğŸ“¢ Track published: ${publication.kind} by ${participant.identity}');
        
        // Handle both audio and data tracks from agents
        final isAgent = participant.identity.toLowerCase().contains('agent') || 
                       participant.identity.toLowerCase().contains('assistant') ||
                       participant.attributes['lk.agent'] == 'true';
        
        print('ğŸ” Is Agent for Track: $isAgent');
        
        if (isAgent) {
          if (publication.kind == TrackType.DATA) {
            print('ğŸ“¡ âœ… AGENT DATA TRACK PUBLISHED - Will receive via DataReceivedEvent');
            _logger.i('ğŸ“¡ Agent data track published - will receive via DataReceivedEvent');
          } else if (publication.kind == TrackType.AUDIO) {
            print('ğŸ¤ âœ… AGENT AUDIO TRACK PUBLISHED - Subscribing...');
            _logger.i('ğŸ¤ Agent audio track published - subscribing for audio');
            publication.subscribe();
          } else {
            print('â“ Unknown track type from agent: ${publication.kind}');
          }
        } else {
          print('âŒ Track from non-agent participant: ${participant.identity}');
        }
      })
      ..on<TrackSubscribedEvent>((event) {
        final track = event.track;
        final participant = event.participant;
        _logger.i('ğŸµ Track subscribed: ${track.kind} from ${participant.identity}');
        
        // Handle agent audio track subscription
        final isAgent = participant.identity.toLowerCase().contains('agent') || 
                       participant.identity.toLowerCase().contains('assistant') ||
                       participant.attributes['lk.agent'] == 'true';
        
        if (isAgent && track is RemoteAudioTrack) {
          _logger.i('ğŸ”Š Agent audio track subscribed - agent is speaking');
          // Set up transcript event listener for real-time speech-to-text
          _setupTranscriptListener(track, participant);
          _handleAgentSpeaking(participant.identity);
        }
      })
      ..on<TrackUnpublishedEvent>((event) {
        print('ğŸ” ============== TRACK UNPUBLISHED DEBUG ==============');
        print('ğŸ” Track Kind: ${event.publication.kind}');
        print('ğŸ” From Participant: ${event.participant.identity}');
        print('ğŸ” ===================================================');
      })
      ..on<TrackUnsubscribedEvent>((event) {
        print('ğŸ” ============= TRACK UNSUBSCRIBED DEBUG =============');
        print('ğŸ” Track Kind: ${event.track.kind}');
        print('ğŸ” From Participant: ${event.participant.identity}');
        print('ğŸ” ==================================================');
      })
      ..on<TrackMutedEvent>((event) {
        print('ğŸ” =============== TRACK MUTED DEBUG ===============');
        print('ğŸ” Track Kind: ${event.publication.kind}');
        print('ğŸ” From Participant: ${event.participant.identity}');
        print('ğŸ” Muted: ${event.publication.muted}');
        print('ğŸ” ===============================================');
      })
      ..on<ActiveSpeakersChangedEvent>((event) {
        print('ğŸ” ============ ACTIVE SPEAKERS CHANGED ============');
        print('ğŸ” Active Speakers: ${event.speakers.map((s) => s.identity).join(", ")}');
        for (final speaker in event.speakers) {
          print('ğŸ”   - ${speaker.identity}: Level ${speaker.audioLevel}');
        }
        print('ğŸ” ===============================================');
      })
      ..on<DataReceivedEvent>((event) {
        try {
          final rawData = utf8.decode(event.data);
          final participant = event.participant;
          
          // COMPREHENSIVE DEBUG LOGGING - COMPLETE AGENT RESPONSE
          print('ğŸ¯ ====================== AGENT RESPONSE RECEIVED ======================');
          print('ğŸ¯ TIMESTAMP: ${DateTime.now().toIso8601String()}');
          print('ğŸ¯ FROM PARTICIPANT: ${participant?.identity ?? "Unknown"}');
          print('ğŸ¯ PARTICIPANT KIND: ${participant?.kind ?? "Unknown"}');
          print('ğŸ¯ PARTICIPANT METADATA: ${participant?.metadata ?? "None"}');
          print('ğŸ¯ PARTICIPANT ATTRIBUTES: ${participant?.attributes ?? "None"}');
          print('ğŸ¯ ');
          print('ğŸ¯ RAW DATA DETAILS:');
          print('ğŸ¯   - Data Length: ${event.data.length} bytes');
          print('ğŸ¯   - Event Topic: ${event.topic ?? "No topic"}');
          print('ğŸ¯   - Raw Bytes: ${event.data}');
          print('ğŸ¯ ');
          print('ğŸ¯ DECODED CONTENT (UTF-8):');
          print('ğŸ¯ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
          print('ğŸ¯ â”‚ $rawData');
          print('ğŸ¯ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜');
          print('ğŸ¯ ');
          print('ğŸ¯ CONTENT PREVIEW (First 200 chars):');
          print('ğŸ¯ ${rawData.length > 200 ? rawData.substring(0, 200) + "..." : rawData}');
          print('ğŸ¯ =====================================================================');
          
          _logger.i('ğŸ“¨ Data received from ${participant?.identity}: $rawData');
          
          // Check if this is from an agent
          final isAgent = participant != null && (
            participant.identity.toLowerCase().contains('agent') || 
            participant.identity.toLowerCase().contains('assistant') ||
            participant.attributes['lk.agent'] == 'true'
          );
          
          print('ğŸ” Is Agent Check: $isAgent');
          print('ğŸ” Agent Identity Contains "agent": ${participant?.identity.toLowerCase().contains('agent') ?? false}');
          print('ğŸ” Agent Identity Contains "assistant": ${participant?.identity.toLowerCase().contains('assistant') ?? false}');
          print('ğŸ” Agent Attributes: ${participant?.attributes}');
          
          if (isAgent && rawData.isNotEmpty) {
            print('âœ… Processing agent data message...');
            _handleDataMessage(rawData, participant);
          } else if (!isAgent) {
            print('âŒ Ignoring message - not from agent');
          } else if (rawData.isEmpty) {
            print('âŒ Ignoring message - empty data');
          }
        } catch (e) {
          print('ğŸ’¥ ERROR processing received data: $e');
          print('ğŸ’¥ Error details: ${e.runtimeType}');
          _logger.w('âš ï¸ Error processing received data: $e');
        }
      });
  }

  void _handleAgentMessage(String message) {
    final timestamp = DateTime.now().toLocal().toString().substring(11, 19);
    final timestampedMessage = '[$timestamp] $message';
    
    print('ğŸ” ============== STORING AGENT MESSAGE DEBUG ==============');
    print('ğŸ” Message: $message');
    print('ğŸ” Timestamped: $timestampedMessage');
    print('ğŸ” Before - Total Messages: ${_agentMessages.length}');
    print('ğŸ” Before - Latest Text: $_latestAgentText');
    
    _agentMessages.add(timestampedMessage);
    _latestAgentText = message;
    
    print('ğŸ” After - Total Messages: ${_agentMessages.length}');
    print('ğŸ” After - Latest Text: $_latestAgentText');
    print('ğŸ” Notifying listeners...');
    print('ğŸ” =====================================================');
    
    _logger.i('ğŸ¤– Agent message captured: $message');
    _logger.i('ğŸ“ Total agent messages: ${_agentMessages.length}');
    
    // Notify listeners and stream subscribers
    notifyListeners();
    _agentMessageController.add(message);
    
    print('âœ… Agent message processed and listeners notified');
  }

  void _handleUserSpeech(String speech) {
    print('ğŸ” ============== USER SPEECH DEBUG ==============');
    print('ğŸ” Speech: $speech');
    print('ğŸ” Length: ${speech.length}');
    print('ğŸ” ==============================================');
    
    _logger.i('ğŸ‘¤ User speech captured: $speech');
    
    // Send to live transcript stream
    _liveTranscriptController.add({
      'speaker': 'user',
      'transcript': speech,
      'timestamp': DateTime.now().toIso8601String(),
      'is_partial': false,
    });
    
    // Notify listeners
    notifyListeners();
    
    print('âœ… User speech processed and listeners notified');
  }

  void _handleLiveTranscript(String transcript, String speaker) {
    print('ğŸ” ============== LIVE TRANSCRIPT DEBUG ==============');
    print('ğŸ” Speaker: $speaker');
    print('ğŸ” Transcript: $transcript');
    print('ğŸ” Length: ${transcript.length}');
    print('ğŸ” =================================================');
    
    if (speaker == 'agent') {
      _currentLiveTranscript = transcript;
      _isAgentSpeaking = true;
      _logger.i('ğŸ“ Live agent transcript: $transcript');
    } else if (speaker == 'user') {
      _currentUserTranscript = transcript;
      _isUserSpeaking = true;
      _logger.i('ğŸ‘¤ Live user transcript: $transcript');
    }
    
    // Send to live transcript stream
    _liveTranscriptController.add({
      'speaker': speaker,
      'transcript': transcript,
      'timestamp': DateTime.now().toIso8601String(),
      'is_partial': true,
    });
    
    // Notify listeners
    notifyListeners();
    
    print('âœ… Live transcript processed and listeners notified');
  }

  void _handleIntermediateMessage(String message) {
    print('ğŸ” ============== INTERMEDIATE MESSAGE DEBUG ==============');
    print('ğŸ” Message: $message');
    print('ğŸ” Length: ${message.length}');
    print('ğŸ” ======================================================');
    
    _logger.i('â³ Intermediate message: $message');
    
    // Add to agent messages with special formatting
    final timestamp = DateTime.now().toLocal().toString().substring(11, 19);
    final timestampedMessage = '[$timestamp] [Processing] $message';
    
    _agentMessages.add(timestampedMessage);
    _latestAgentText = message;
    
    // Send to live transcript stream as agent message
    _liveTranscriptController.add({
      'speaker': 'agent',
      'transcript': message,
      'timestamp': DateTime.now().toIso8601String(),
      'is_partial': false,
      'is_intermediate': true,
    });
    
    // Notify listeners
    notifyListeners();
    
    print('âœ… Intermediate message processed and listeners notified');
  }

  // Method to send user configuration to agent
  Future<void> sendUserConfigurationToAgent() async {
    if (_room == null || _localParticipant == null) {
      _logger.w('âš ï¸ Cannot send user configuration: not connected to room');
      return;
    }

    try {
      final userConfig = {
        'type': 'user_configuration',
        'user_id': _currentUserId ?? 'default-user',
        'chatlog_id': _currentChatlogId ?? 7747,
        'agent_id': _currentAgentId ?? 6,
        'user_email': _currentUserEmail ?? '',
        'user_name': _currentUserName ?? 'Mobile User',
        'timestamp': DateTime.now().toIso8601String(),
      };

      await _localParticipant!.publishData(
        data: utf8.encode(jsonEncode(userConfig)),
        topic: 'user_config',
      );

      _logger.i('ğŸ“¤ User configuration sent to agent: ${userConfig['user_id']}');
    } catch (e) {
      _logger.e('âŒ Error sending user configuration: $e');
    }
  }

  // Method to update user configuration and notify agent
  Future<void> updateUserConfiguration({
    String? userId,
    int? chatlogId,
    int? agentId,
    String? userEmail,
    String? userName,
  }) async {
    // Update local configuration
    setUserConfiguration(
      userId: userId,
      chatlogId: chatlogId,
      agentId: agentId,
      userEmail: userEmail,
      userName: userName,
    );

    // Send to agent if connected
    if (_isConnected) {
      await sendUserConfigurationToAgent();
    }
  }

  void _handleUserConfigConfirmation(String message) {
    print('ğŸ” ============== USER CONFIG CONFIRMATION DEBUG ==============');
    print('ğŸ” Message: $message');
    print('ğŸ” Length: ${message.length}');
    print('ğŸ” ===========================================================');
    
    _logger.i('âœ… User config confirmation: $message');
    
    // Add to agent messages with special formatting
    final timestamp = DateTime.now().toLocal().toString().substring(11, 19);
    final timestampedMessage = '[$timestamp] [Config] $message';
    
    _agentMessages.add(timestampedMessage);
    _latestAgentText = message;
    
    // Send to live transcript stream as agent message
    _liveTranscriptController.add({
      'speaker': 'agent',
      'transcript': message,
      'timestamp': DateTime.now().toIso8601String(),
      'is_partial': false,
      'is_config_confirmation': true,
    });
    
    // Notify listeners
    notifyListeners();
    
    print('âœ… User config confirmation processed and listeners notified');
  }

  void _handleAutomaticGreeting(String message) {
    print('ğŸ” ============== AUTOMATIC GREETING DEBUG ==============');
    print('ğŸ” Message: $message');
    print('ğŸ” Length: ${message.length}');
    print('ğŸ” =====================================================');
    
    _logger.i('ğŸ¤– Automatic greeting: $message');
    
    // Add to agent messages with special formatting
    final timestamp = DateTime.now().toLocal().toString().substring(11, 19);
    final timestampedMessage = '[$timestamp] [Welcome] $message';
    
    _agentMessages.add(timestampedMessage);
    _latestAgentText = message;
    
    // Send to live transcript stream as agent message
    _liveTranscriptController.add({
      'speaker': 'agent',
      'transcript': message,
      'timestamp': DateTime.now().toIso8601String(),
      'is_partial': false,
      'is_automatic_greeting': true,
    });
    
    // Notify listeners
    notifyListeners();
    
    print('ğŸ¤– Automatic greeting processed and listeners notified');
  }

  void _handleDataMessage(String rawData, RemoteParticipant? participant) {
    print('ğŸ” ================= PROCESSING DATA MESSAGE =================');
    print('ğŸ” Raw Data: $rawData');
    print('ğŸ” Data Length: ${rawData.length}');
    print('ğŸ” From Participant: ${participant?.identity}');
    
    try {
      // Try to parse as JSON first (structured messages)
      print('ğŸ” Attempting JSON parse...');
      final messageData = jsonDecode(rawData) as Map<String, dynamic>;
      final messageType = messageData['type'] as String?;
      final content = messageData['content'] as String?;
      final timestamp = messageData['timestamp'] as String?;
      
      print('âœ… JSON PARSED SUCCESSFULLY:');
      print('ğŸ”   Type: $messageType');
      print('ğŸ”   Content: $content');
      print('ğŸ”   Timestamp: $timestamp');
      print('ğŸ”   Full JSON: $messageData');
      
      _logger.i('ğŸ“Š JSON message parsed - type: $messageType, content: ${content?.substring(0, 50)}...');
      
      if (messageType == 'daily_briefing' && content != null) {
        print('ğŸ“‹ DAILY BRIEFING DETECTED - Processing...');
        _dailyBriefing = content;
        _dailyBriefingReceived = true;
        _handleAgentMessage(content);
        print('ğŸ“‹ Daily Briefing stored successfully');
        _logger.i('ğŸ“‹ Daily Briefing Received and stored');
      } else if (messageType == 'agent_response' && content != null) {
        print('ğŸ¤– AGENT RESPONSE DETECTED - Processing...');
        _handleAgentMessage(content);
        print('ğŸ¤– Agent Response stored successfully');
        _logger.i('ğŸ¤– Agent Response captured');
      } else if (messageType == 'message' && content != null) {
        print('ğŸ’¬ AGENT MESSAGE DETECTED - Processing...');
        _handleAgentMessage(content);
        print('ğŸ’¬ Agent Message stored successfully');
        _logger.i('ğŸ’¬ Agent Message captured');
      } else if (messageType == 'loading' && content != null) {
        print('â³ LOADING MESSAGE DETECTED - Processing...');
        _handleAgentMessage(content);
        print('â³ Loading message stored successfully');
        _logger.i('â³ Loading message captured');
      } else if (messageType == 'user_speech' && content != null) {
        print('ğŸ‘¤ USER SPEECH DETECTED - Processing...');
        _handleUserSpeech(content);
        print('ğŸ‘¤ User speech stored successfully');
        _logger.i('ğŸ‘¤ User speech captured');
      } else if (messageType == 'live_transcript' && content != null) {
        print('ğŸ“ LIVE TRANSCRIPT DETECTED - Processing...');
        _handleLiveTranscript(content, 'agent');
        print('ğŸ“ Live Transcript stored successfully');
        _logger.i('ğŸ“ Live Transcript captured');
      } else if (messageType == 'user_live_transcript' && content != null) {
        print('ğŸ‘¤ USER LIVE TRANSCRIPT DETECTED - Processing...');
        _handleLiveTranscript(content, 'user');
        print('ğŸ‘¤ User Live Transcript stored successfully');
        _logger.i('ğŸ‘¤ User Live Transcript captured');
      } else if (messageType == 'intermediate_message' && content != null) {
        print('â³ INTERMEDIATE MESSAGE DETECTED - Processing...');
        _handleIntermediateMessage(content);
        print('â³ Intermediate message stored successfully');
        _logger.i('â³ Intermediate message captured');
      } else if (messageType == 'user_config_confirmation' && content != null) {
        print('âœ… USER CONFIG CONFIRMATION DETECTED - Processing...');
        _handleUserConfigConfirmation(content);
        print('âœ… User config confirmation stored successfully');
        _logger.i('âœ… User config confirmation captured');
      } else if (messageType == 'automatic_greeting' && content != null) {
        print('ğŸ¤– AUTOMATIC GREETING DETECTED - Processing...');
        _handleAutomaticGreeting(content);
        print('ğŸ¤– Automatic greeting stored successfully');
        _logger.i('ğŸ¤– Automatic greeting captured');
      } else {
        print('â“ UNKNOWN MESSAGE TYPE: $messageType');
        print('â“ Content: $content');
      }
    } catch (e) {
      // If JSON parsing fails, treat as plain text (fallback)
      print('âš ï¸ JSON PARSE FAILED - Treating as plain text');
      print('âš ï¸ Error: $e');
      print('ğŸ“ Raw text content: $rawData');
      _logger.i('ğŸ“ Raw text message (non-JSON): $rawData');
      _handleAgentMessage(rawData);
    }
    
    print('ğŸ” Current Agent State After Processing:');
    print('ğŸ”   Total Messages: ${_agentMessages.length}');
    print('ğŸ”   Latest Text: $_latestAgentText');
    print('ğŸ”   Daily Briefing: $_dailyBriefing');
    print('ğŸ”   Daily Briefing Received: $_dailyBriefingReceived');
    print('ğŸ” ========================================================');
  }

  void _setupTranscriptListener(RemoteAudioTrack track, RemoteParticipant participant) {
    // Set up transcript event listener for real-time speech-to-text
    track.addListener(() {
      // Listen for transcript events on the audio track
      _logger.i('ğŸ¤ Audio track listener added for transcript events');
    });
    
    // Note: In LiveKit Flutter SDK, transcript events might be handled differently
    // This is the pattern from your backend code - may need adjustment for Flutter SDK
    _logger.i('ğŸ“ Transcript listener set up for ${participant.identity}');
  }

  void _handleTranscript(String transcriptText, RemoteParticipant participant) {
    _logger.i('ğŸ“ Transcript received: $transcriptText');
    
    // Add transcript as agent message
    _handleAgentMessage(transcriptText);
    
    // Check if this is a daily briefing
    if (transcriptText.toLowerCase().contains('daily_briefing') && !_dailyBriefingReceived) {
      _dailyBriefing = transcriptText;
      _dailyBriefingReceived = true;
      _logger.i('ğŸ“‹ Daily Briefing detected in transcript');
    }
  }

  void _handleAgentSpeaking(String agentIdentity) {
    print('ğŸ¤ ================= AGENT SPEAKING DETECTED =================');
    print('ğŸ¤ Agent Identity: $agentIdentity');
    print('ğŸ¤ Audio Track Subscribed - Agent is now speaking');
    print('ğŸ¤ Waiting for text data via DataReceivedEvent...');
    print('ğŸ¤ ');
    print('ğŸ¤ IMPORTANT: If you hear the agent but see no "AGENT RESPONSE RECEIVED"');
    print('ğŸ¤ messages below, it means the backend is NOT sending text data.');
    print('ğŸ¤ ');
    print('ğŸ¤ The agent should send JSON like:');
    print('ğŸ¤ {"type":"daily_briefing","content":"Your text here","timestamp":"..."}');
    print('ğŸ¤ ============================================================');
    
    _logger.i('ğŸ™ï¸ Agent is speaking - waiting for real transcribed data via DataReceivedEvent');
    _logger.i('ğŸ” If no text appears, the agent may not be configured to send transcription data');
  }

  // Method to clear agent messages (useful for fresh sessions)
  void clearAgentMessages() {
    _agentMessages.clear();
    _latestAgentText = '';
    _dailyBriefing = null;
    _dailyBriefingReceived = false;
    _logger.i('ğŸ§¹ Agent messages cleared');
    notifyListeners();
  }

  // Method to clear live transcripts
  void clearLiveTranscripts() {
    _currentLiveTranscript = '';
    _currentUserTranscript = '';
    _isAgentSpeaking = false;
    _isUserSpeaking = false;
    _logger.i('ğŸ§¹ Live transcripts cleared');
    notifyListeners();
  }

  // Method to stop agent speaking (when speech ends)
  void stopAgentSpeaking() {
    _isAgentSpeaking = false;
    _currentLiveTranscript = '';
    _logger.i('ğŸ”‡ Agent stopped speaking');
    notifyListeners();
  }

  // Method to stop user speaking (when speech ends)
  void stopUserSpeaking() {
    _isUserSpeaking = false;
    _currentUserTranscript = '';
    _logger.i('ğŸ”‡ User stopped speaking');
    notifyListeners();
  }

  // Method for external components to add agent messages (if needed)
  void addAgentMessage(String message) {
    _logger.i('ğŸ“ External agent message added: $message');
    _handleAgentMessage(message);
  }

  // No test methods - only real agent data capture

  Future<void> _enableAudioWithDelay() async {
    // Wait for connection to stabilize
    await Future.delayed(const Duration(seconds: 2));
    
    try {
      if (_room?.localParticipant != null) {
        await _room!.localParticipant!.setMicrophoneEnabled(true);
        _isMicrophoneMuted = false;
        _isAudioEnabled = true;
        _connectionStatus = 'Connected (Audio Ready)';
        _logger.i('ğŸ¤ Microphone enabled for full-duplex audio');
        notifyListeners();
      }
    } catch (e) {
      _logger.w('âš ï¸ Failed to enable microphone: $e');
    }
  }

  void _updateParticipants() {
    if (_room == null) return;

    _localParticipant = _room!.localParticipant;
    _remoteParticipants = _room!.remoteParticipants.values.toList();
    _participantCount = _remoteParticipants.length + 1; // +1 for local participant
  }

  Future<void> toggleMicrophone() async {
    if (!_isAudioEnabled || _room?.localParticipant == null) return;

    try {
      _isMicrophoneMuted = !_isMicrophoneMuted;
      await _room!.localParticipant!.setMicrophoneEnabled(!_isMicrophoneMuted);
      notifyListeners();
    } catch (e) {
      _logger.w('âš ï¸ Failed to toggle microphone: $e');
    }
  }

  void _handleConnectionError(String error) {
    _isConnected = false;
    _isConnecting = false;
    _connectionStatus = 'Failed';
    _error = error;
    _cleanup();
    notifyListeners();
  }

  Future<void> disconnect() async {
    _logger.i('ğŸ”Œ Disconnecting from LiveKit...');
    
    try {
      // First, disable audio to stop transmission
      if (_room?.localParticipant != null) {
        _logger.i('ğŸ¤ Disabling microphone...');
        await _room!.localParticipant!.setMicrophoneEnabled(false);
      }
      
      // Update state immediately
      _isConnected = false;
      _isConnecting = false;
      _connectionStatus = 'Disconnecting...';
      notifyListeners();
      
      // Properly disconnect from the room
      if (_room != null) {
        _logger.i('ğŸšª Leaving room...');
        await _room!.disconnect();
        await _room!.dispose();
        _logger.i('âœ… Room disconnected and disposed');
      }
      
      // Clean up all state
      _cleanup();
      _connectionStatus = 'Disconnected';
      
      _logger.i('âœ… Successfully disconnected from LiveKit');
      notifyListeners();
      
    } catch (e) {
      _logger.w('âš ï¸ Error during disconnect: $e');
      // Force cleanup even if there was an error
      _cleanup();
      _connectionStatus = 'Disconnected';
      notifyListeners();
    }
  }

  void _cleanup() {
    _logger.i('ğŸ§¹ Cleaning up LiveKit service...');
    _room = null;
    _localParticipant = null;
    _remoteParticipants.clear();
    _participantCount = 0;
    _isMicrophoneMuted = true;
    _isAudioEnabled = false;
    _error = null;
    
    // Clear agent messages on cleanup
    _agentMessages.clear();
    _latestAgentText = '';
    _dailyBriefing = null;
    _dailyBriefingReceived = false;
    
    // Clear live transcripts on cleanup
    _currentLiveTranscript = '';
    _currentUserTranscript = '';
    _isAgentSpeaking = false;
    _isUserSpeaking = false;
    
    _logger.i('âœ… Cleanup completed');
  }

  bool isParticipantSpeaking(RemoteParticipant participant) {
    // Simple implementation - you can enhance this with actual audio level detection
    return false;
  }

  String getParticipantDisplayName(RemoteParticipant participant) {
    return participant.identity.isNotEmpty ? participant.identity : 'Unknown';
  }

  @override
  void dispose() {
    disconnect();
    _agentMessageController.close();
    _liveTranscriptController.close();
    super.dispose();
  }
} 
